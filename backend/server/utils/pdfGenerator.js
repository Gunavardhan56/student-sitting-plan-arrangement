import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create pdfs directory if it doesn't exist
const pdfsDir = path.join(__dirname, '../../pdfs');
if (!fs.existsSync(pdfsDir)) {
  fs.mkdirSync(pdfsDir, { recursive: true });
}

export const generatePDF = (seatingResult) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ 
        margin: 50,
        size: 'A4',
        layout: 'portrait'
      });
      
      const fileName = `seating-plan-${seatingResult._id}.pdf`;
      const filePath = path.join(pdfsDir, fileName);
      
      // Pipe the PDF into a file
      doc.pipe(fs.createWriteStream(filePath));
      
      // Add title page (summary)
      doc.fontSize(20)
         .text('Student Seating Plan Arrangement', 50, 50, { align: 'center' });
      
      doc.fontSize(12)
         .text(`Exam Type: ${seatingResult.examType.toUpperCase()}`, 50, 100)
         .text(`Total Students: ${seatingResult.totalStudents}`, 50, 120)
         .text(`Total Capacity: ${seatingResult.totalCapacity}`, 50, 140)
         .text(`Generated By: ${seatingResult.createdBy}`, 50, 160)
         .text(`Generated On: ${seatingResult.createdAt.toDateString()}`, 50, 180);
      
      doc.moveDown(2);

      // Start seating arrangements on a new page to avoid overlapping the summary
      doc.addPage();
      
      // Add seating arrangements for each classroom
      seatingResult.placements.forEach((placement, index) => {
        if (index > 0) {
          doc.addPage();
        }
        
        // Classroom title
        doc.fontSize(16)
           .text(`Classroom: ${placement.classroomNo}`, 50, 50, { align: 'center' });
        
        doc.moveDown(1);
        
        const grid = placement.grid;
        const rows = grid.length;
        const cols = grid[0] ? grid[0].length : 0;
        
        if (rows === 0 || cols === 0) {
          doc.fontSize(12)
             .text('No seating arrangement for this classroom', 50, 100);
          return;
        }
        
        // Calculate cell dimensions
        const tableWidth = 500;
        const tableHeight = 400;
        const cellWidth = tableWidth / cols;
        const cellHeight = Math.min(tableHeight / rows, 40);
        
        const startX = 50;
        const startY = 100;
        
        // Draw table headers (column numbers)
        doc.fontSize(10);
        for (let col = 0; col < cols; col++) {
          const x = startX + col * cellWidth;
          const y = startY - 20;
          doc.rect(x, y, cellWidth, 20)
             .stroke()
             .text(`Col ${col + 1}`, x + 5, y + 5, {
               width: cellWidth - 10,
               align: 'center'
             });
        }
        
        // Draw table with seating arrangement
        for (let row = 0; row < rows; row++) {
          // Row header
          const rowHeaderX = startX - 40;
          const rowHeaderY = startY + row * cellHeight;
          doc.rect(rowHeaderX, rowHeaderY, 35, cellHeight)
             .stroke()
             .text(`R${row + 1}`, rowHeaderX + 5, rowHeaderY + cellHeight/2 - 5, {
               width: 25,
               align: 'center'
             });
          
          for (let col = 0; col < cols; col++) {
            const x = startX + col * cellWidth;
            const y = startY + row * cellHeight;
            
            // Draw cell border
            doc.rect(x, y, cellWidth, cellHeight).stroke();
            
            // Add student roll number or empty indicator
            const rollNo = grid[row][col];
            const text = rollNo || 'EMPTY';
            const fontSize = rollNo ? 9 : 8;
            const textColor = rollNo ? 'black' : 'gray';
            
            doc.fontSize(fontSize)
               .fillColor(textColor)
               .text(text, x + 2, y + cellHeight/2 - 6, {
                 width: cellWidth - 4,
                 align: 'center'
               })
               .fillColor('black'); // Reset color
          }
        }
        
        // Add legend
        const legendY = startY + rows * cellHeight + 30;
        doc.fontSize(10)
           .text('Legend:', 50, legendY)
           .text('• Each cell represents one seat', 50, legendY + 15)
           .text('• EMPTY = Unoccupied seat', 50, legendY + 30)
           .text('• Numbers = Student roll numbers', 50, legendY + 45);
        
        // Add seating statistics for this classroom
        const occupiedSeats = grid.flat().filter(seat => seat !== null).length;
        const totalSeats = rows * cols;
        
        doc.fontSize(10)
           .text(`Classroom Statistics:`, 350, legendY)
           .text(`Total Seats: ${totalSeats}`, 350, legendY + 15)
           .text(`Occupied: ${occupiedSeats}`, 350, legendY + 30)
           .text(`Empty: ${totalSeats - occupiedSeats}`, 350, legendY + 45);
      });
      
      // Add summary page
      doc.addPage();
      doc.fontSize(16)
         .text('Summary', 50, 50, { align: 'center' });
      
      doc.fontSize(12)
         .moveDown(1);
      
      // Calculate overall statistics
      let totalOccupied = 0;
      let totalSeats = 0;
      
      seatingResult.placements.forEach(placement => {
        const occupied = placement.grid.flat().filter(seat => seat !== null).length;
        const seats = placement.grid.length * (placement.grid[0] ? placement.grid[0].length : 0);
        totalOccupied += occupied;
        totalSeats += seats;
        
        doc.text(`${placement.classroomNo}: ${occupied}/${seats} seats occupied`);
      });
      
      doc.moveDown(1)
         .fontSize(14)
         .text(`Overall Utilization: ${totalOccupied}/${totalSeats} (${((totalOccupied/totalSeats)*100).toFixed(1)}%)`, { align: 'center' });
      
      // Add exam type specific information
      doc.moveDown(1)
         .fontSize(12);
      
      if (seatingResult.examType === 'semester') {
        doc.text('Semester Exam Arrangement:', { underline: true })
           .text('• Students are arranged with alternating departments')
           .text('• No two adjacent seats have students from the same department')
           .text('• This prevents cheating between students of the same course');
      } else if (seatingResult.examType === 'mid') {
        doc.text('Mid-term Exam Arrangement:', { underline: true })
           .text('• Senior students (3rd & 4th year) are paired with junior students (1st & 2nd year)')
           .text('• This arrangement facilitates mentoring and reduces anxiety')
           .text('• Roll numbers are arranged in ascending order within year groups');
      }
      
      // Footer
      doc.fontSize(8)
         .text(`Generated on ${new Date().toLocaleString()}`, 50, 750, { align: 'center' })
         .text('This is a computer-generated document. No signature required.', 50, 765, { align: 'center' });
      
      // Finalize the PDF
      doc.end();
      
      // Wait for the PDF to be written
      doc.on('end', () => {
        resolve(filePath);
      });
      
      doc.on('error', (error) => {
        reject(error);
      });
      
    } catch (error) {
      reject(error);
    }
  });
};